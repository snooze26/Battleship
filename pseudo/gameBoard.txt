create a class called battleField
    create battleField variable globally 
    create an array for the attackCoords
    create a ships object that contains a property for the ships on the board "shipsAfloat"


DONEDONEDONEDONEDONEDONEDONEDONEDONE
constructor(row , col){ 
    set row and col to the inputed values 
    run the createBattleField on row and col properties with bField
}
********************

DONEDONEDONEDONEDONEDONEDONEDONEDONE
createBattleField(rows, col) { 
    return
        create a empty array of arrays named with the row value
            make array mappable by spreading these elements
            map through the rows and enter an array of columns 
            fill these columns with "-" as the placeholder for the board 
}
********************

validLocation(position) { 
    create boardLimit and assign it to 8 
    create an object that takes in x ,y variables assign poistion to it
    check if x is greater than or equal to 0 and if x is less than board limit 
    check if y is greater than or equal to 0 and if y is less than board limit 
        if true, return true
    else if false return false 
}

** done 


getCell(input) { DONE **********
    check if the input type is not a string throw error
    split the coordinates into a variable called "coords" 
    check if the length of coords equal 2 
        if false then throw a error for the valid format 

    parseInt both numbers and trim the white space with a radix of 10 

    check if both numbers are integers if not then throw errors 
    return both numbers in an array
}

placeShip(coords, ship) { 
    check if # of coords is equal to ship's length if false
         return false 
    if coords overflow then
         return false 
    if coords are not free then 
        return false 

    for each coordinate 
        split coords into x and y 
        set battleField's x and y to ship 
    
    increase the shipsAfloat property by 1 
    call the blockedCell function to find the blocked cells around the ship 
    
    IN the ships object 
        create a new entrty with ship's Id as the key 
        set value of new entry to an object holding: 
            properties:
                blockedcells - list of surrounding blocked cells
                shipCoords - list of ship's coords 

    return list of ship coords and blockedCells 
}

recieveAttack(input) { 
    check if the input coords are valid if false return (making sure input coordinates are valid)
    split the coordinates into a variable called "coords" (collecting the inputs and seperating from punctuations)
    check if the coords return a valid cell, if false then return function (checking if the coordinate is a valid space)
    check if the coords are in the attackCoords array if true then return (checking if the coords have already been hit)
    create a variable cell that is retrieving the coordinates using x & y . (retrieves cell contents: the ship object)
    add coordinates to the attackCoords array; (adds the cell to the attackcoords array making it not hittable anymore)
    check if the coordinates have already been attacked 
        mark the ship if it has been hit 
        assign the ship to the cell and hit the ship 
            if ship has been sunk 
                remove one ship from the board and make the cell content "X"
                // add a identifier property to the ship class and a shipDamage property 
                assign the ship's blockedCells using it's identifier to a shipsDamage variable 
                push the blockedCells into the attackCoords variable 
                return the ship with the status now as sunk and damage is assigned to shipsDamage 
        ship has been hit but not sunk. 
        mark the cell as "X"
        return status as hit and damage is assigned to shipsDamage 
    ship has not been hit. return the status as miss and damage as null
    
}

isAttackMarker(cell) {
    create a variable that 
}

allShipsSunk() { DONE********
    return shipAfloat equal to 0 
}

clearBoard() { 
    reassign battleField to a new battleField using the createBoard function with the # of rows and cols
    set attackCoords to an empty array 
    reset the ships object shipAfloat proeprty to 0 
}

getbattleField() { DONE 
    return the battleField 
 }

howManyShips() { DONEEEEEE
    return shipsAfloat
}

retrieveSurroundingCells(coords) { 
    define the 8 directions around a cell using shipsDirections
    create a array called shipMoves and assign it to empty array

    for each offset(x and y) in shipsDirections
        for each coord in coordinates 
        split coord into x and y parts 
        convert x and y to numbers 

        calculate newX = x + offset of x 
        newY = x + offset of y 

        if newX/newY are not valid cells 
            skip to next coord
        if the cell at newX/Y is not "X" or "-"
            skip to next coord 
        
        Add newX/Y as a string to shipMoves 
    
    define newShipMoves to remove duplicate coords from shipMoves

    return newShipMoves
}

surroundShipWithBlockedCells(shipCoords) { 
    define surroundingCells by calling retrieveSurroundingCells with shipCoords as its input 
    create an empty array called acc for the accumlator 
    for each coord in surroundingCells 
        split coord into x and y 
        convert x and y into numbers 
        Set the cell at x and y on the battleField to "X" marking it as blocked 
        add coord to acc array 
    return acc (all blocked cell coords)
}

isCoordsFree(coords) { 
    define freeCoords by calling filter on coords 
        filter criteria:
            for each coordinate 
                split the the coords 
                assign x and y to the split coords 
                define cell by calling retrieveCell with x and y as the inputed values 
                if cell's value is "-" and not "X" add the coord to freeCoords
        return true if freeCoords.length is equal to coords.length         
}

isCoordsOverflowing(coords) { 
    define validCoords by calling filter on coords 
        filter criteria: 
            for each coordinate
                split the coords 
                assing x and y to the split coords 
                return true if x and y coords are a valid cell 
        return true if validCoords length is equal to coords' length 
}




